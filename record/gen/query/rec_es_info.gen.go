// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/summer-gonner/traffica/record/gen/model"
)

func newRecEsInfo(db *gorm.DB, opts ...gen.DOOption) recEsInfo {
	_recEsInfo := recEsInfo{}

	_recEsInfo.recEsInfoDo.UseDB(db, opts...)
	_recEsInfo.recEsInfoDo.UseModel(&model.RecEsInfo{})

	tableName := _recEsInfo.recEsInfoDo.TableName()
	_recEsInfo.ALL = field.NewAsterisk(tableName)
	_recEsInfo.ID = field.NewInt64(tableName, "id")
	_recEsInfo.Username = field.NewString(tableName, "username")
	_recEsInfo.Password = field.NewString(tableName, "password")
	_recEsInfo.Address = field.NewString(tableName, "address")
	_recEsInfo.Remark = field.NewString(tableName, "remark")
	_recEsInfo.IsDeleted = field.NewInt32(tableName, "is_deleted")
	_recEsInfo.CreateBy = field.NewString(tableName, "create_by")
	_recEsInfo.CreateTime = field.NewTime(tableName, "create_time")
	_recEsInfo.UpdateBy = field.NewString(tableName, "update_by")
	_recEsInfo.UpdateTime = field.NewTime(tableName, "update_time")
	_recEsInfo.ConnectTime = field.NewTime(tableName, "connect_time")
	_recEsInfo.Result = field.NewString(tableName, "result")
	_recEsInfo.Name = field.NewString(tableName, "name")

	_recEsInfo.fillFieldMap()

	return _recEsInfo
}

type recEsInfo struct {
	recEsInfoDo recEsInfoDo

	ALL         field.Asterisk
	ID          field.Int64  // 编号
	Username    field.String // 用户名
	Password    field.String // 密码
	Address     field.String // 地址
	Remark      field.String // 备注信息
	IsDeleted   field.Int32  // 是否删除  0：否  1：是
	CreateBy    field.String // 创建者
	CreateTime  field.Time   // 创建时间
	UpdateBy    field.String // 更新者
	UpdateTime  field.Time   // 更新时间
	ConnectTime field.Time   // 连接时间
	Result      field.String // 连接结果
	Name        field.String // es名字

	fieldMap map[string]field.Expr
}

func (r recEsInfo) Table(newTableName string) *recEsInfo {
	r.recEsInfoDo.UseTable(newTableName)
	return r.updateTableName(newTableName)
}

func (r recEsInfo) As(alias string) *recEsInfo {
	r.recEsInfoDo.DO = *(r.recEsInfoDo.As(alias).(*gen.DO))
	return r.updateTableName(alias)
}

func (r *recEsInfo) updateTableName(table string) *recEsInfo {
	r.ALL = field.NewAsterisk(table)
	r.ID = field.NewInt64(table, "id")
	r.Username = field.NewString(table, "username")
	r.Password = field.NewString(table, "password")
	r.Address = field.NewString(table, "address")
	r.Remark = field.NewString(table, "remark")
	r.IsDeleted = field.NewInt32(table, "is_deleted")
	r.CreateBy = field.NewString(table, "create_by")
	r.CreateTime = field.NewTime(table, "create_time")
	r.UpdateBy = field.NewString(table, "update_by")
	r.UpdateTime = field.NewTime(table, "update_time")
	r.ConnectTime = field.NewTime(table, "connect_time")
	r.Result = field.NewString(table, "result")
	r.Name = field.NewString(table, "name")

	r.fillFieldMap()

	return r
}

func (r *recEsInfo) WithContext(ctx context.Context) IRecEsInfoDo {
	return r.recEsInfoDo.WithContext(ctx)
}

func (r recEsInfo) TableName() string { return r.recEsInfoDo.TableName() }

func (r recEsInfo) Alias() string { return r.recEsInfoDo.Alias() }

func (r recEsInfo) Columns(cols ...field.Expr) gen.Columns { return r.recEsInfoDo.Columns(cols...) }

func (r *recEsInfo) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := r.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (r *recEsInfo) fillFieldMap() {
	r.fieldMap = make(map[string]field.Expr, 13)
	r.fieldMap["id"] = r.ID
	r.fieldMap["username"] = r.Username
	r.fieldMap["password"] = r.Password
	r.fieldMap["address"] = r.Address
	r.fieldMap["remark"] = r.Remark
	r.fieldMap["is_deleted"] = r.IsDeleted
	r.fieldMap["create_by"] = r.CreateBy
	r.fieldMap["create_time"] = r.CreateTime
	r.fieldMap["update_by"] = r.UpdateBy
	r.fieldMap["update_time"] = r.UpdateTime
	r.fieldMap["connect_time"] = r.ConnectTime
	r.fieldMap["result"] = r.Result
	r.fieldMap["name"] = r.Name
}

func (r recEsInfo) clone(db *gorm.DB) recEsInfo {
	r.recEsInfoDo.ReplaceConnPool(db.Statement.ConnPool)
	return r
}

func (r recEsInfo) replaceDB(db *gorm.DB) recEsInfo {
	r.recEsInfoDo.ReplaceDB(db)
	return r
}

type recEsInfoDo struct{ gen.DO }

type IRecEsInfoDo interface {
	gen.SubQuery
	Debug() IRecEsInfoDo
	WithContext(ctx context.Context) IRecEsInfoDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IRecEsInfoDo
	WriteDB() IRecEsInfoDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IRecEsInfoDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IRecEsInfoDo
	Not(conds ...gen.Condition) IRecEsInfoDo
	Or(conds ...gen.Condition) IRecEsInfoDo
	Select(conds ...field.Expr) IRecEsInfoDo
	Where(conds ...gen.Condition) IRecEsInfoDo
	Order(conds ...field.Expr) IRecEsInfoDo
	Distinct(cols ...field.Expr) IRecEsInfoDo
	Omit(cols ...field.Expr) IRecEsInfoDo
	Join(table schema.Tabler, on ...field.Expr) IRecEsInfoDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IRecEsInfoDo
	RightJoin(table schema.Tabler, on ...field.Expr) IRecEsInfoDo
	Group(cols ...field.Expr) IRecEsInfoDo
	Having(conds ...gen.Condition) IRecEsInfoDo
	Limit(limit int) IRecEsInfoDo
	Offset(offset int) IRecEsInfoDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IRecEsInfoDo
	Unscoped() IRecEsInfoDo
	Create(values ...*model.RecEsInfo) error
	CreateInBatches(values []*model.RecEsInfo, batchSize int) error
	Save(values ...*model.RecEsInfo) error
	First() (*model.RecEsInfo, error)
	Take() (*model.RecEsInfo, error)
	Last() (*model.RecEsInfo, error)
	Find() ([]*model.RecEsInfo, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.RecEsInfo, err error)
	FindInBatches(result *[]*model.RecEsInfo, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.RecEsInfo) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IRecEsInfoDo
	Assign(attrs ...field.AssignExpr) IRecEsInfoDo
	Joins(fields ...field.RelationField) IRecEsInfoDo
	Preload(fields ...field.RelationField) IRecEsInfoDo
	FirstOrInit() (*model.RecEsInfo, error)
	FirstOrCreate() (*model.RecEsInfo, error)
	FindByPage(offset int, limit int) (result []*model.RecEsInfo, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IRecEsInfoDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (r recEsInfoDo) Debug() IRecEsInfoDo {
	return r.withDO(r.DO.Debug())
}

func (r recEsInfoDo) WithContext(ctx context.Context) IRecEsInfoDo {
	return r.withDO(r.DO.WithContext(ctx))
}

func (r recEsInfoDo) ReadDB() IRecEsInfoDo {
	return r.Clauses(dbresolver.Read)
}

func (r recEsInfoDo) WriteDB() IRecEsInfoDo {
	return r.Clauses(dbresolver.Write)
}

func (r recEsInfoDo) Session(config *gorm.Session) IRecEsInfoDo {
	return r.withDO(r.DO.Session(config))
}

func (r recEsInfoDo) Clauses(conds ...clause.Expression) IRecEsInfoDo {
	return r.withDO(r.DO.Clauses(conds...))
}

func (r recEsInfoDo) Returning(value interface{}, columns ...string) IRecEsInfoDo {
	return r.withDO(r.DO.Returning(value, columns...))
}

func (r recEsInfoDo) Not(conds ...gen.Condition) IRecEsInfoDo {
	return r.withDO(r.DO.Not(conds...))
}

func (r recEsInfoDo) Or(conds ...gen.Condition) IRecEsInfoDo {
	return r.withDO(r.DO.Or(conds...))
}

func (r recEsInfoDo) Select(conds ...field.Expr) IRecEsInfoDo {
	return r.withDO(r.DO.Select(conds...))
}

func (r recEsInfoDo) Where(conds ...gen.Condition) IRecEsInfoDo {
	return r.withDO(r.DO.Where(conds...))
}

func (r recEsInfoDo) Order(conds ...field.Expr) IRecEsInfoDo {
	return r.withDO(r.DO.Order(conds...))
}

func (r recEsInfoDo) Distinct(cols ...field.Expr) IRecEsInfoDo {
	return r.withDO(r.DO.Distinct(cols...))
}

func (r recEsInfoDo) Omit(cols ...field.Expr) IRecEsInfoDo {
	return r.withDO(r.DO.Omit(cols...))
}

func (r recEsInfoDo) Join(table schema.Tabler, on ...field.Expr) IRecEsInfoDo {
	return r.withDO(r.DO.Join(table, on...))
}

func (r recEsInfoDo) LeftJoin(table schema.Tabler, on ...field.Expr) IRecEsInfoDo {
	return r.withDO(r.DO.LeftJoin(table, on...))
}

func (r recEsInfoDo) RightJoin(table schema.Tabler, on ...field.Expr) IRecEsInfoDo {
	return r.withDO(r.DO.RightJoin(table, on...))
}

func (r recEsInfoDo) Group(cols ...field.Expr) IRecEsInfoDo {
	return r.withDO(r.DO.Group(cols...))
}

func (r recEsInfoDo) Having(conds ...gen.Condition) IRecEsInfoDo {
	return r.withDO(r.DO.Having(conds...))
}

func (r recEsInfoDo) Limit(limit int) IRecEsInfoDo {
	return r.withDO(r.DO.Limit(limit))
}

func (r recEsInfoDo) Offset(offset int) IRecEsInfoDo {
	return r.withDO(r.DO.Offset(offset))
}

func (r recEsInfoDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IRecEsInfoDo {
	return r.withDO(r.DO.Scopes(funcs...))
}

func (r recEsInfoDo) Unscoped() IRecEsInfoDo {
	return r.withDO(r.DO.Unscoped())
}

func (r recEsInfoDo) Create(values ...*model.RecEsInfo) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Create(values)
}

func (r recEsInfoDo) CreateInBatches(values []*model.RecEsInfo, batchSize int) error {
	return r.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (r recEsInfoDo) Save(values ...*model.RecEsInfo) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Save(values)
}

func (r recEsInfoDo) First() (*model.RecEsInfo, error) {
	if result, err := r.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.RecEsInfo), nil
	}
}

func (r recEsInfoDo) Take() (*model.RecEsInfo, error) {
	if result, err := r.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.RecEsInfo), nil
	}
}

func (r recEsInfoDo) Last() (*model.RecEsInfo, error) {
	if result, err := r.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.RecEsInfo), nil
	}
}

func (r recEsInfoDo) Find() ([]*model.RecEsInfo, error) {
	result, err := r.DO.Find()
	return result.([]*model.RecEsInfo), err
}

func (r recEsInfoDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.RecEsInfo, err error) {
	buf := make([]*model.RecEsInfo, 0, batchSize)
	err = r.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (r recEsInfoDo) FindInBatches(result *[]*model.RecEsInfo, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return r.DO.FindInBatches(result, batchSize, fc)
}

func (r recEsInfoDo) Attrs(attrs ...field.AssignExpr) IRecEsInfoDo {
	return r.withDO(r.DO.Attrs(attrs...))
}

func (r recEsInfoDo) Assign(attrs ...field.AssignExpr) IRecEsInfoDo {
	return r.withDO(r.DO.Assign(attrs...))
}

func (r recEsInfoDo) Joins(fields ...field.RelationField) IRecEsInfoDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Joins(_f))
	}
	return &r
}

func (r recEsInfoDo) Preload(fields ...field.RelationField) IRecEsInfoDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Preload(_f))
	}
	return &r
}

func (r recEsInfoDo) FirstOrInit() (*model.RecEsInfo, error) {
	if result, err := r.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.RecEsInfo), nil
	}
}

func (r recEsInfoDo) FirstOrCreate() (*model.RecEsInfo, error) {
	if result, err := r.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.RecEsInfo), nil
	}
}

func (r recEsInfoDo) FindByPage(offset int, limit int) (result []*model.RecEsInfo, count int64, err error) {
	result, err = r.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = r.Offset(-1).Limit(-1).Count()
	return
}

func (r recEsInfoDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = r.Count()
	if err != nil {
		return
	}

	err = r.Offset(offset).Limit(limit).Scan(result)
	return
}

func (r recEsInfoDo) Scan(result interface{}) (err error) {
	return r.DO.Scan(result)
}

func (r recEsInfoDo) Delete(models ...*model.RecEsInfo) (result gen.ResultInfo, err error) {
	return r.DO.Delete(models)
}

func (r *recEsInfoDo) withDO(do gen.Dao) *recEsInfoDo {
	r.DO = *do.(*gen.DO)
	return r
}
